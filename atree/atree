#!/usr/bin/python
# Vladimir Slavik, Red Hat, 2018

from __future__ import print_function
import sys
import re
from os.path import dirname, basename, isfile, isdir
from os.path import join as pjoin
from os import getcwd, chdir
from glob import glob

include_finder = re.compile(r"(\/\/)?.*include\:\:([^\[]+)\[") # specific enough, but does not include the parameters
comment_finder = re.compile(r"(\/{4,})")
ifdef_finder = re.compile(r"(\/\/)?.*((?:ifdef|ifndef|ifeval|endif)::[^\[]*)\[\]") # needs empty brackets at end = skips inline content

do_debug = False
indent_level = 4

def debug_print(*var) :
  if do_debug :
    print(*var)

stack = []

class AFile :
  
  def __init__(self, fname, parent_path="") :
    debug_print("AFile.__init__", fname, parent_path)
    self.fname = fname
    self.parent_path = parent_path
    self.includes = []
    self.commented = False
    self.conditions = []
    
  def resolve(self) :
    debug_print("resolve()")
    this_path = dirname(self.fname)
    try :
      if self.parent_path :
        f = open(self.parent_path + "/" + self.fname, "r")
        debug_print("open() ", self.parent_path + "/" + self.fname)
      else :
        f = open(self.fname, "r")
        debug_print("open() ", self.fname)
      lines = f.readlines()
      f.close()
      debug_print("read ok")
      for line in lines :
        # see if there is include on this line
        include_found = include_finder.findall(line)
        for include in include_found :
          debug_print("include::", include[1])
          new_file = AFile(include[1], pjoin(self.parent_path, this_path))
          new_file.commented = new_file.commented or (include[0] == "//") or (stack and stack[-1].startswith("//")) or self.commented
          # this ^^^ is about determining status of the found include
          new_file.conditions = [i for i in stack]
          self.includes.append(new_file)
        # this vvv is about determining if a multiline comment starts or ends here (instead)
        comment_found = comment_finder.findall(line)
        for comment in comment_found :
          if stack and stack[-1] == comment :
            stack.pop()
          else :
            stack.append(comment)
        # see if there is a preprocessor condition
        ifdef_found = ifdef_finder.findall(line)
        for ifdef in ifdef_found :
          if ifdef[0] != "//" : # is the condition not-commented out?
            if ifdef[1].startswith("endif") :
              stack.pop() # assumes there are no condition crossovers
            else :
              stack.append(ifdef[1])
          # else: silently drop commented-out conditions
    except Exception as e :
      debug_print("Exception caught for resolve()")
      debug_print("self.fname ", self.fname)
      debug_print("self.parent_path", self.parent_path)
      debug_print("curdir ", getcwd())
      debug_print("error ", e)
    for subfile in self.includes :
      subfile.resolve()
  
  def print_tree(self, level=0) :
    if self.commented :
      print(" "*indent_level*level + "// " + self.fname)
    else :
      print(" "*indent_level*level + self.fname)
    cond = ""
    for s in self.conditions :
      if not s.startswith("//") :
        cond += " " + s
    if cond :
      print(" "*indent_level*(level+1) + "\\- !!! "+ cond)
    for subfile in self.includes :
      subfile.print_tree(level+1)


def guess_file() :
  # see if there is master.adoc, index.adoc, or a single .adoc file, in that order, and return that file or empty string
  debug_print("guess_file()")
  if isfile("master.adoc") :
    return "master.adoc"
  elif isfile("index.adoc") :
    return "index.adoc"
  else :
    adocs = glob("*.adoc")
    if len(adocs) == 1 :
      return adocs[0]
  return ""


def analyze_path(knownfile) :
	# takes a path that is a known existing file under current situation
	top = AFile(knownfile)
	top.resolve()
	top.print_tree()


def process_path(somepath) :
	debug_print("process_path()")
	the_file = basename(somepath)
	the_dir = dirname(somepath)
	debug_print(somepath, "//", the_dir, "//", the_file)
	# now handle when a directory is given instead of a file (must always guess then)
	if the_dir and not the_file :
		# if parameter is given like some/dir/ with trailing slash (eg. shell autocomplete)
		chdir(the_dir)
		the_file = guess_file()
		if not the_file :
			print("Could not guess an AsciiDoc file in directory %s" % (the_dir))
		else :
			analyze_path(the_file)
	elif isdir(the_file) :
		# if parameter is given as some/dir without trailing slash (eg. manually)
		target = pjoin(the_dir,the_file)
		chdir(target)
		the_file = guess_file()
		if not the_file :
			print("Could not guess an AsciiDoc file in directory %s" % (target))
			exit(1)
		analyze_path(the_file)
	elif the_dir :
		# if parameter is given as some/dir/file.adoc and has a dir component
		chdir(the_dir)
		analyze_path(the_file)
	else :
		# if it's given as file.adoc with no directory
		analyze_path(the_file)



# MAIN
curdir = getcwd()
debug_print(sys.argv)
if len(sys.argv) < 2 :
	# called with no params, must guess the file
	the_file = guess_file()
	if not the_file :
		# could not guess, let's fail
		print("No parameters specified and no file found that you obviously wanted to be automagically guessed.")
		exit(1)
	else :
		# found a default file
		process_path(the_file)
else :
	# called with exact params specifying files or dirs
	items = sys.argv[1:]
	debug_print(items)
	nitems = len(items)
	for i in range(nitems) :
		item = items[i]
		print("Listing %s:" % (item))
		chdir(curdir)
		process_path(item)
		if i < nitems-1 :
			print() # empty line

# EOF
